// Основа - алгоритм Эллера
#include <stdio.h>
#include <conio.h>
#include <graphics.h>
#include <ctime>
const int N=600; // ширина
const int M=600; // высота
const int R=10; // размер лабиринта (в клетках)

void LRight (int x, int y, int color) { 
     setcolor(color);
     moveto(x+10,y-10);
     lineto(x+10,y+10);
}

void LBot (int x, int y, int color) { 
     setcolor(color);
     moveto(x+10,y+10);
     lineto(x-10,y+10);
}

void LabBuiltNDraw() {
   int x, y, MN[R][R], PG[R][R], NG[R][R], i, j, z, k, flagO, flagE;
   srand(time(0));
   for (i=0; i<R; i++) MN[0][i]=i+1; // 1. Создайте первую строку. Ни одна ячейка не будет являться частью ни одного множества
   for (i=0; i<R; i++) { 
       if (i) // 5.1. Если вы хотите добавить ещё одну строку, то:
       for (j=0; j<R; j++) { 
           MN[i][j]=MN[i-1][j]; NG[i][j]=NG[i-1][j];// 5.1.1. Выведите текущую строку
           PG[i][j]=0; // 5.1.2. Удалите все правые границы
           if (NG[i][j]) MN[i][j]=0; // 5.1.3. Удалите ячейки с нижней границей из их множества
           NG[i][j]=0; // 5.1.4. Удалите все нижние границы
       } // 5.1.5. Продолжайте с шага 2
       for (j=0; j<R; j++) { // 2. Присвойте ячейкам, не входящим в множество, своё уникальное множество
           if (MN[i][j]==0) { 
               for (k=1,z=0; z<R; z++) {
                   if (k==MN[i][z]) k++;
               }
               MN[i][j]=k;
           }
       }
       for (j=0; j<R; j++) { // 3. Создайте правые границы, двигаяся слева направо
           if (MN[i][j]==MN[i][j+1]) PG[i][j]=1; // 3.1.1. Если текущая ячейка и ячейка справа принадлежат одному множеству, то создайте границу между ними (для предотвращения зацикливаний)
           else PG[i][j]=rand()%1+0; // 3.1. Случайно решите, добавлять границу или нет
           if (PG[i][j]==0) MN[i][j+1]=MN[i][j]; // 3.1.2. Если вы решили не добавлять границу, то объедините два множества в котороых находится текущая ячейка и ячейка справа
       }
       for (j=0; j<R; j++) { // 4. Создайте границу снизу, двигаясь слева направо
           flagO=0;
           for (z=0; z<R; z++) {// Проверка на "одиночество"
                if (MN[i][j]==MN[i][z] && z!=j) flagO=1;
           }
           if (flagO) { 
               flagE=0;
               for (z=0; z<R; z++) { // Проверка на "неединственность"
                   if (MN[i][j]==MN[i][z] && z!=j && NG[i][z]==0) flagE=1;
               }
               if (flagE) {
                   NG[i][j]=rand()%1+0; // 4.1. Случайно решите, добавлять границу или нет
               } else NG[i][j]=0; // 4.1.2. Если ячейка одна в своем множестве без нижней границы, то не создавайте нижнюю границу
           } else NG[i][j]=0; // 4.1.1. Если ячейка в своем множестве одна, то не создавайте границу снизу 
       }
       if (i==R-1) { // 5.2. Если вы решите закончить лабиринт, то:
           for (j=0; j<R; j++) { //5.2.2. Двигаясь слева направо:
               NG[i][j]=1; // 5.2.1. Добавьте нижнюю границу к каждой ячейке
               if (MN[i][j]!=MN[i][j+1]) { // 5.2.2.1. Если текущая ячейка и ячейка справа члены разных множеств, то:
                   PG[i][j]=0; // 5.2.2.1.1. Удалите правую границу
                   MN[i][j+1]=MN[i][j]; // 5.2.2.1.2. Объедините множества текущей ячейки и ячейки справа
               }
           }
       }
   }
   initwindow(N,M);
   for (i=0; i<R; i++)
       for (j=0; j<R; j++) {
           if (PG[i][j]) LRight(10*j+5,10*i+5,15);
           if (NG[i][j]) LBot(10*j+5,10*i+5,15);
       }
}

main() {
       LabBuiltNDraw();
       getch();
}
